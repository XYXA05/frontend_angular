import { ChangeDetectionStrategy, Component, ContentChild, Directive, Input, TemplateRef, } from '@angular/core';
import { fromEvent, merge, Subscription } from 'rxjs';
import { filter, startWith, switchMap } from 'rxjs/operators';
import { MarkerComponent } from '../marker/marker.component';
import { NgFor, NgIf, NgTemplateOutlet } from '@angular/common';
import { LayerComponent } from '../layer/layer.component';
import * as i0 from "@angular/core";
import * as i1 from "../map/map.service";
/**
 * a template directive for point for {@link MarkersForClustersComponent}
 *
 * @category Directives
 */
export class PointDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: PointDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.1", type: PointDirective, isStandalone: true, selector: "ng-template[mglPoint]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: PointDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ng-template[mglPoint]',
                    standalone: true,
                }]
        }] });
/**
 * a template directive for clustered point for {@link MarkersForClustersComponent}
 *
 * @category Directives
 */
export class ClusterPointDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: ClusterPointDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.1", type: ClusterPointDirective, isStandalone: true, selector: "ng-template[mglClusterPoint]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: ClusterPointDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ng-template[mglClusterPoint]',
                    standalone: true,
                }]
        }] });
let uniqId = 0;
/**
 * [ngx] `mgl-markers-for-clusters` - an HTML marker component for clustered points.
 * Requires a geojson source that is clustered.
 *
 * @category Components
 *
 * @example
 * ```html
 * ...
 * <mgl-map ...>
 *   <mgl-markers-for-cluster [source]="myGeoJsonclusteredSource">
 *     <ng-template mglPoint let-feature> Marker! </ng-template>
 *     <ng-template mglClusterPoint let-feature>
 *       ClusterId: {{feature.properties?.cluster_id}}, Points:
 *       {{feature.properties?.point_count}}
 *     </ng-template>
 *   </mgl-markers-for-cluster>
 * </mgl-map>
 * ```
 *
 * Note: Only use this if you **really** need to use HTML/Angular component to render your symbols. This is **slower** than rendering symbols in WebGL.
 */
export class MarkersForClustersComponent {
    constructor(mapService, changeDetectorRef, ngZone) {
        this.mapService = mapService;
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        /** @hidden */
        this.layerId = `mgl-markers-for-clusters-${uniqId++}`;
        this.sub = new Subscription();
    }
    ngAfterContentInit() {
        const clusterDataUpdate = () => fromEvent(this.mapService.mapInstance, 'data').pipe(filter((e) => e.sourceId === this.source &&
            e.sourceDataType !== 'metadata' &&
            this.mapService.mapInstance.isSourceLoaded(this.source)));
        const sub = this.mapService.mapCreated$
            .pipe(switchMap(clusterDataUpdate), switchMap(() => merge(fromEvent(this.mapService.mapInstance, 'move'), fromEvent(this.mapService.mapInstance, 'moveend')).pipe(startWith(undefined))))
            .subscribe(() => {
            this.ngZone.run(() => {
                this.updateCluster();
            });
        });
        this.sub.add(sub);
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    trackByClusterPoint(_index, clusterPoint) {
        return clusterPoint.id;
    }
    updateCluster() {
        const params = { layers: [this.layerId] };
        if (!this.pointTpl) {
            params.filter = ['==', 'cluster', true];
        }
        this.clusterPoints = this.mapService.mapInstance.queryRenderedFeatures(params);
        this.changeDetectorRef.markForCheck();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: MarkersForClustersComponent, deps: [{ token: i1.MapService }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.1", type: MarkersForClustersComponent, isStandalone: true, selector: "mgl-markers-for-clusters", inputs: { source: "source" }, queries: [{ propertyName: "pointTpl", first: true, predicate: PointDirective, descendants: true, read: TemplateRef }, { propertyName: "clusterPointTpl", first: true, predicate: ClusterPointDirective, descendants: true, read: TemplateRef }], ngImport: i0, template: `
    <mgl-layer
      [id]="layerId"
      [source]="source"
      type="circle"
      [paint]="{ 'circle-radius': 0 }"
    ></mgl-layer>
    <ng-container
      *ngFor="let feature of clusterPoints; trackBy: trackByClusterPoint"
    >
      <ng-container *ngIf="feature.properties.cluster">
        <mgl-marker [feature]="feature">
          <ng-container
            *ngTemplateOutlet="clusterPointTpl; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
      <ng-container *ngIf="!feature.properties.cluster">
        <mgl-marker [feature]="feature">
          <ng-container
            *ngTemplateOutlet="pointTpl; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
    </ng-container>
  `, isInline: true, dependencies: [{ kind: "component", type: LayerComponent, selector: "mgl-layer", inputs: ["id", "source", "type", "metadata", "sourceLayer", "removeSource", "filter", "layout", "paint", "before", "minzoom", "maxzoom"], outputs: ["layerClick", "layerDblClick", "layerMouseDown", "layerMouseUp", "layerMouseEnter", "layerMouseLeave", "layerMouseMove", "layerMouseOver", "layerMouseOut", "layerContextMenu", "layerTouchStart", "layerTouchEnd", "layerTouchCancel"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: MarkerComponent, selector: "mgl-marker", inputs: ["offset", "anchor", "clickTolerance", "color", "feature", "lngLat", "draggable", "popupShown", "className", "pitchAlignment", "rotationAlignment", "rotation"], outputs: ["markerDragStart", "markerDragEnd", "markerDrag"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: MarkersForClustersComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'mgl-markers-for-clusters',
                    template: `
    <mgl-layer
      [id]="layerId"
      [source]="source"
      type="circle"
      [paint]="{ 'circle-radius': 0 }"
    ></mgl-layer>
    <ng-container
      *ngFor="let feature of clusterPoints; trackBy: trackByClusterPoint"
    >
      <ng-container *ngIf="feature.properties.cluster">
        <mgl-marker [feature]="feature">
          <ng-container
            *ngTemplateOutlet="clusterPointTpl; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
      <ng-container *ngIf="!feature.properties.cluster">
        <mgl-marker [feature]="feature">
          <ng-container
            *ngTemplateOutlet="pointTpl; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
    </ng-container>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    standalone: true,
                    imports: [LayerComponent, NgFor, NgIf, MarkerComponent, NgTemplateOutlet],
                }]
        }], ctorParameters: () => [{ type: i1.MapService }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }], propDecorators: { source: [{
                type: Input
            }], pointTpl: [{
                type: ContentChild,
                args: [PointDirective, { read: TemplateRef, static: false }]
            }], clusterPointTpl: [{
                type: ContentChild,
                args: [ClusterPointDirective, { read: TemplateRef, static: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya2Vycy1mb3ItY2x1c3RlcnMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LW1hcGxpYnJlLWdsL3NyYy9saWIvbWFya2Vycy1mb3ItY2x1c3RlcnMvbWFya2Vycy1mb3ItY2x1c3RlcnMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFlBQVksRUFDWixTQUFTLEVBQ1QsS0FBSyxFQUdMLFdBQVcsR0FDWixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFOUQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzdELE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDOzs7QUFFMUQ7Ozs7R0FJRztBQUtILE1BQU0sT0FBTyxjQUFjOzhHQUFkLGNBQWM7a0dBQWQsY0FBYzs7MkZBQWQsY0FBYztrQkFKMUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsdUJBQXVCO29CQUNqQyxVQUFVLEVBQUUsSUFBSTtpQkFDakI7O0FBR0Q7Ozs7R0FJRztBQUtILE1BQU0sT0FBTyxxQkFBcUI7OEdBQXJCLHFCQUFxQjtrR0FBckIscUJBQXFCOzsyRkFBckIscUJBQXFCO2tCQUpqQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSw4QkFBOEI7b0JBQ3hDLFVBQVUsRUFBRSxJQUFJO2lCQUNqQjs7QUFHRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7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Ozs7Ozs7Ozs7OztHQXlCVDtvQkFDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsbUJBQW1CLEVBQUUsS0FBSztvQkFDMUIsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLE9BQU8sRUFBRSxDQUFDLGNBQWMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsQ0FBQztpQkFDMUU7b0lBSVUsTUFBTTtzQkFBZCxLQUFLO2dCQUlOLFFBQVE7c0JBRFAsWUFBWTt1QkFBQyxjQUFjLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7Z0JBSWxFLGVBQWU7c0JBRGQsWUFBWTt1QkFBQyxxQkFBcUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIERpcmVjdGl2ZSxcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBUZW1wbGF0ZVJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXBHZW9KU09ORmVhdHVyZSwgTWFwU291cmNlRGF0YUV2ZW50IH0gZnJvbSAnbWFwbGlicmUtZ2wnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBtZXJnZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHN0YXJ0V2l0aCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC9tYXAuc2VydmljZSc7XG5pbXBvcnQgeyBNYXJrZXJDb21wb25lbnQgfSBmcm9tICcuLi9tYXJrZXIvbWFya2VyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOZ0ZvciwgTmdJZiwgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBMYXllckNvbXBvbmVudCB9IGZyb20gJy4uL2xheWVyL2xheWVyLmNvbXBvbmVudCc7XG5cbi8qKlxuICogYSB0ZW1wbGF0ZSBkaXJlY3RpdmUgZm9yIHBvaW50IGZvciB7QGxpbmsgTWFya2Vyc0ZvckNsdXN0ZXJzQ29tcG9uZW50fVxuICogXG4gKiBAY2F0ZWdvcnkgRGlyZWN0aXZlc1xuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICduZy10ZW1wbGF0ZVttZ2xQb2ludF0nLFxuICBzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBQb2ludERpcmVjdGl2ZSB7fVxuXG4vKipcbiAqIGEgdGVtcGxhdGUgZGlyZWN0aXZlIGZvciBjbHVzdGVyZWQgcG9pbnQgZm9yIHtAbGluayBNYXJrZXJzRm9yQ2x1c3RlcnNDb21wb25lbnR9XG4gKiBcbiAqIEBjYXRlZ29yeSBEaXJlY3RpdmVzXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ25nLXRlbXBsYXRlW21nbENsdXN0ZXJQb2ludF0nLFxuICBzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBDbHVzdGVyUG9pbnREaXJlY3RpdmUge31cblxubGV0IHVuaXFJZCA9IDA7XG5cbi8qKlxuICogW25neF0gYG1nbC1tYXJrZXJzLWZvci1jbHVzdGVyc2AgLSBhbiBIVE1MIG1hcmtlciBjb21wb25lbnQgZm9yIGNsdXN0ZXJlZCBwb2ludHMuXG4gKiBSZXF1aXJlcyBhIGdlb2pzb24gc291cmNlIHRoYXQgaXMgY2x1c3RlcmVkLlxuICogXG4gKiBAY2F0ZWdvcnkgQ29tcG9uZW50c1xuICogXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogLi4uXG4gKiA8bWdsLW1hcCAuLi4+XG4gKiAgIDxtZ2wtbWFya2Vycy1mb3ItY2x1c3RlciBbc291cmNlXT1cIm15R2VvSnNvbmNsdXN0ZXJlZFNvdXJjZVwiPlxuICogICAgIDxuZy10ZW1wbGF0ZSBtZ2xQb2ludCBsZXQtZmVhdHVyZT4gTWFya2VyISA8L25nLXRlbXBsYXRlPlxuICogICAgIDxuZy10ZW1wbGF0ZSBtZ2xDbHVzdGVyUG9pbnQgbGV0LWZlYXR1cmU+XG4gKiAgICAgICBDbHVzdGVySWQ6IHt7ZmVhdHVyZS5wcm9wZXJ0aWVzPy5jbHVzdGVyX2lkfX0sIFBvaW50czpcbiAqICAgICAgIHt7ZmVhdHVyZS5wcm9wZXJ0aWVzPy5wb2ludF9jb3VudH19XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9tZ2wtbWFya2Vycy1mb3ItY2x1c3Rlcj5cbiAqIDwvbWdsLW1hcD5cbiAqIGBgYFxuICogXG4gKiBOb3RlOiBPbmx5IHVzZSB0aGlzIGlmIHlvdSAqKnJlYWxseSoqIG5lZWQgdG8gdXNlIEhUTUwvQW5ndWxhciBjb21wb25lbnQgdG8gcmVuZGVyIHlvdXIgc3ltYm9scy4gVGhpcyBpcyAqKnNsb3dlcioqIHRoYW4gcmVuZGVyaW5nIHN5bWJvbHMgaW4gV2ViR0wuXG4gKi8gXG4gQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWdsLW1hcmtlcnMtZm9yLWNsdXN0ZXJzJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bWdsLWxheWVyXG4gICAgICBbaWRdPVwibGF5ZXJJZFwiXG4gICAgICBbc291cmNlXT1cInNvdXJjZVwiXG4gICAgICB0eXBlPVwiY2lyY2xlXCJcbiAgICAgIFtwYWludF09XCJ7ICdjaXJjbGUtcmFkaXVzJzogMCB9XCJcbiAgICA+PC9tZ2wtbGF5ZXI+XG4gICAgPG5nLWNvbnRhaW5lclxuICAgICAgKm5nRm9yPVwibGV0IGZlYXR1cmUgb2YgY2x1c3RlclBvaW50czsgdHJhY2tCeTogdHJhY2tCeUNsdXN0ZXJQb2ludFwiXG4gICAgPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImZlYXR1cmUucHJvcGVydGllcy5jbHVzdGVyXCI+XG4gICAgICAgIDxtZ2wtbWFya2VyIFtmZWF0dXJlXT1cImZlYXR1cmVcIj5cbiAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImNsdXN0ZXJQb2ludFRwbDsgY29udGV4dDogeyAkaW1wbGljaXQ6IGZlYXR1cmUgfVwiXG4gICAgICAgICAgPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L21nbC1tYXJrZXI+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhZmVhdHVyZS5wcm9wZXJ0aWVzLmNsdXN0ZXJcIj5cbiAgICAgICAgPG1nbC1tYXJrZXIgW2ZlYXR1cmVdPVwiZmVhdHVyZVwiPlxuICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwicG9pbnRUcGw7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBmZWF0dXJlIH1cIlxuICAgICAgICAgID48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9tZ2wtbWFya2VyPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9uZy1jb250YWluZXI+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgaW1wb3J0czogW0xheWVyQ29tcG9uZW50LCBOZ0ZvciwgTmdJZiwgTWFya2VyQ29tcG9uZW50LCBOZ1RlbXBsYXRlT3V0bGV0XSxcbn0pXG5leHBvcnQgY2xhc3MgTWFya2Vyc0ZvckNsdXN0ZXJzQ29tcG9uZW50XG4gIGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0IHtcbiAgLyoqIEluaXQgaW5wdXQgKi9cbiAgQElucHV0KCkgc291cmNlOiBzdHJpbmc7XG5cbiAgLyoqIEBoaWRkZW4gKi9cbiAgQENvbnRlbnRDaGlsZChQb2ludERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiBmYWxzZSB9KVxuICBwb2ludFRwbD86IFRlbXBsYXRlUmVmPGFueT47XG4gIC8qKiBAaGlkZGVuICovXG4gIEBDb250ZW50Q2hpbGQoQ2x1c3RlclBvaW50RGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IGZhbHNlIH0pXG4gIGNsdXN0ZXJQb2ludFRwbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogQGhpZGRlbiAqL1xuICBjbHVzdGVyUG9pbnRzOiBNYXBHZW9KU09ORmVhdHVyZVtdO1xuICAvKiogQGhpZGRlbiAqL1xuICBsYXllcklkID0gYG1nbC1tYXJrZXJzLWZvci1jbHVzdGVycy0ke3VuaXFJZCsrfWA7XG5cbiAgcHJpdmF0ZSBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBtYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLFxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmVcbiAgKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBjb25zdCBjbHVzdGVyRGF0YVVwZGF0ZSA9ICgpID0+XG4gICAgICBmcm9tRXZlbnQ8TWFwU291cmNlRGF0YUV2ZW50Pih0aGlzLm1hcFNlcnZpY2UubWFwSW5zdGFuY2UsICdkYXRhJykucGlwZShcbiAgICAgICAgZmlsdGVyKFxuICAgICAgICAgIChlKSA9PlxuICAgICAgICAgICAgZS5zb3VyY2VJZCA9PT0gdGhpcy5zb3VyY2UgJiZcbiAgICAgICAgICAgIGUuc291cmNlRGF0YVR5cGUgIT09ICdtZXRhZGF0YScgJiZcbiAgICAgICAgICAgIHRoaXMubWFwU2VydmljZS5tYXBJbnN0YW5jZS5pc1NvdXJjZUxvYWRlZCh0aGlzLnNvdXJjZSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICBjb25zdCBzdWIgPSB0aGlzLm1hcFNlcnZpY2UubWFwQ3JlYXRlZCRcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoY2x1c3RlckRhdGFVcGRhdGUpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cbiAgICAgICAgICBtZXJnZShcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLm1hcFNlcnZpY2UubWFwSW5zdGFuY2UsICdtb3ZlJyksXG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5tYXBTZXJ2aWNlLm1hcEluc3RhbmNlLCAnbW92ZWVuZCcpXG4gICAgICAgICAgKS5waXBlKHN0YXJ0V2l0aCh1bmRlZmluZWQpKVxuICAgICAgICApXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNsdXN0ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB0aGlzLnN1Yi5hZGQoc3ViKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICB0cmFja0J5Q2x1c3RlclBvaW50KF9pbmRleDogbnVtYmVyLCBjbHVzdGVyUG9pbnQ6IHsgaWQ6IG51bWJlciB9KSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJQb2ludC5pZDtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ2x1c3RlcigpIHtcbiAgICBjb25zdCBwYXJhbXM6IGFueSA9IHsgbGF5ZXJzOiBbdGhpcy5sYXllcklkXSB9O1xuICAgIGlmICghdGhpcy5wb2ludFRwbCkge1xuICAgICAgcGFyYW1zLmZpbHRlciA9IFsnPT0nLCAnY2x1c3RlcicsIHRydWVdO1xuICAgIH1cbiAgICB0aGlzLmNsdXN0ZXJQb2ludHMgPSB0aGlzLm1hcFNlcnZpY2UubWFwSW5zdGFuY2UucXVlcnlSZW5kZXJlZEZlYXR1cmVzKFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG59XG4iXX0=