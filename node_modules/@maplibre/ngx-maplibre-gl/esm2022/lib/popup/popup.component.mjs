import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewChild, afterNextRender, } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../map/map.service";
/**
 * `mgl-popup` - a popup component
 * @see [Popup](https://maplibre.org/maplibre-gl-js/docs/API/classes/Popup/)
 *
 * @category Components
 *
 * @example
 * ```html
 * ...
 * <mgl-map ...>
 *   <mgl-popup [lngLat]="[-96, 37.8]" [closeOnClick]="false">
 *     <h1>Hello world !</h1>
 *   </mgl-popup>
 *   ...
 *   <mgl-marker #myMarker ...> ... </mgl-marker>
 *   <mgl-popup [marker]="myMarker"> Hello from marker ! </mgl-popup>
 * </mgl-map>
 * ```
 */
export class PopupComponent {
    constructor(mapService) {
        this.mapService = mapService;
        this.popupClose = new EventEmitter();
        this.popupOpen = new EventEmitter();
        afterNextRender(() => {
            this.popupInstance = this.createPopup();
            this.addPopup(this.popupInstance);
        });
    }
    ngOnInit() {
        if ((this.lngLat && this.marker) ||
            (this.feature && this.lngLat) ||
            (this.feature && this.marker)) {
            throw new Error('marker, lngLat, feature input are mutually exclusive');
        }
    }
    ngOnChanges(changes) {
        if (changes.feature && !changes.feature.isFirstChange()) {
            const newlngLat = changes.lngLat
                ? this.lngLat
                : this.feature.geometry.coordinates;
            this.mapService.removePopupFromMap(this.popupInstance, true);
            const popupInstanceTmp = this.createPopup();
            this.mapService.addPopupToMap(popupInstanceTmp, newlngLat, this.popupInstance.isOpen());
            this.popupInstance = popupInstanceTmp;
        }
        if (changes.lngLat && !changes.lngLat.isFirstChange()) {
            this.popupInstance.setLngLat(this.lngLat);
        }
        if (changes.marker && !changes.marker.isFirstChange()) {
            const previousMarker = changes.marker.previousValue;
            if (previousMarker.markerInstance) {
                this.mapService.removePopupFromMarker(previousMarker.markerInstance);
            }
            if (this.marker && this.marker.markerInstance && this.popupInstance) {
                this.mapService.addPopupToMarker(this.marker.markerInstance, this.popupInstance);
            }
        }
        if (changes.offset &&
            !changes.offset.isFirstChange() &&
            this.popupInstance) {
            this.popupInstance.setOffset(this.offset);
        }
    }
    ngOnDestroy() {
        if (this.popupInstance) {
            if (this.lngLat || this.feature) {
                this.mapService.removePopupFromMap(this.popupInstance);
            }
            else if (this.marker && this.marker.markerInstance) {
                this.mapService.removePopupFromMarker(this.marker.markerInstance);
            }
        }
        this.popupInstance = undefined;
    }
    createPopup() {
        return this.mapService.createPopup({
            popupOptions: {
                closeButton: this.closeButton,
                closeOnClick: this.closeOnClick,
                closeOnMove: this.closeOnMove,
                focusAfterOpen: this.focusAfterOpen,
                anchor: this.anchor,
                offset: this.offset,
                className: this.className,
                maxWidth: this.maxWidth,
            },
            popupEvents: {
                popupOpen: this.popupOpen,
                popupClose: this.popupClose,
            },
        }, this.content.nativeElement);
    }
    addPopup(popup) {
        this.mapService.mapCreated$.subscribe(() => {
            if (this.lngLat || this.feature) {
                this.mapService.addPopupToMap(popup, this.lngLat
                    ? this.lngLat
                    : this.feature.geometry.coordinates);
            }
            else if (this.marker && this.marker.markerInstance) {
                this.mapService.addPopupToMarker(this.marker.markerInstance, popup);
            }
            else {
                throw new Error('mgl-popup need either lngLat/marker/feature to be set');
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: PopupComponent, deps: [{ token: i1.MapService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.1", type: PopupComponent, isStandalone: true, selector: "mgl-popup", inputs: { closeButton: "closeButton", closeOnClick: "closeOnClick", closeOnMove: "closeOnMove", focusAfterOpen: "focusAfterOpen", anchor: "anchor", className: "className", maxWidth: "maxWidth", feature: "feature", lngLat: "lngLat", marker: "marker", offset: "offset" }, outputs: { popupClose: "popupClose", popupOpen: "popupOpen" }, viewQueries: [{ propertyName: "content", first: true, predicate: ["content"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: '<div #content data-cy="mgl-popup"><ng-content></ng-content></div>', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: PopupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'mgl-popup',
                    template: '<div #content data-cy="mgl-popup"><ng-content></ng-content></div>',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i1.MapService }], propDecorators: { closeButton: [{
                type: Input
            }], closeOnClick: [{
                type: Input
            }], closeOnMove: [{
                type: Input
            }], focusAfterOpen: [{
                type: Input
            }], anchor: [{
                type: Input
            }], className: [{
                type: Input
            }], maxWidth: [{
                type: Input
            }], feature: [{
                type: Input
            }], lngLat: [{
                type: Input
            }], marker: [{
                type: Input
            }], offset: [{
                type: Input
            }], popupClose: [{
                type: Output
            }], popupOpen: [{
                type: Output
            }], content: [{
                type: ViewChild,
                args: ['content', { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wdXAuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LW1hcGxpYnJlLWdsL3NyYy9saWIvcG9wdXAvcG9wdXAuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUVULFlBQVksRUFDWixLQUFLLEVBSUwsTUFBTSxFQUVOLFNBQVMsRUFDVCxlQUFlLEdBQ2hCLE1BQU0sZUFBZSxDQUFDOzs7QUFLdkI7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQU9ILE1BQU0sT0FBTyxjQUFjO0lBdUN6QixZQUFvQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBUmhDLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBQ3RDLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBUTdDLGVBQWUsQ0FBQyxHQUFHLEVBQUU7WUFDbkIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBc0IsQ0FBQyxDQUFDO1FBQzdDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELFFBQVE7UUFDTixJQUNFLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQzVCLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQzdCLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQzdCLENBQUM7WUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7UUFDMUUsQ0FBQztJQUNILENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxPQUFPLENBQUMsT0FBTyxJQUFJLENBQUMsT0FB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QUFRLEVBQUUsbUVBQW1FO29CQUM3RSxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOytFQUdVLFdBQVc7c0JBQW5CLEtBQUs7Z0JBRUcsWUFBWTtzQkFBcEIsS0FBSztnQkFFRyxXQUFXO3NCQUFuQixLQUFLO2dCQUVHLGNBQWM7c0JBQXRCLEtBQUs7Z0JBRUcsTUFBTTtzQkFBZCxLQUFLO2dCQUVHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBRUcsUUFBUTtzQkFBaEIsS0FBSztnQkFNRyxPQUFPO3NCQUFmLEtBQUs7Z0JBRUcsTUFBTTtzQkFBZCxLQUFLO2dCQUtHLE1BQU07c0JBQWQsS0FBSztnQkFFRyxNQUFNO3NCQUFkLEtBQUs7Z0JBRUksVUFBVTtzQkFBbkIsTUFBTTtnQkFDRyxTQUFTO3NCQUFsQixNQUFNO2dCQUdpQyxPQUFPO3NCQUE5QyxTQUFTO3VCQUFDLFNBQVMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFZpZXdDaGlsZCxcbiAgYWZ0ZXJOZXh0UmVuZGVyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExuZ0xhdExpa2UsIE9mZnNldCwgUG9wdXAsIFBvcHVwT3B0aW9ucyB9IGZyb20gJ21hcGxpYnJlLWdsJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAvbWFwLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFya2VyQ29tcG9uZW50IH0gZnJvbSAnLi4vbWFya2VyL21hcmtlci5jb21wb25lbnQnO1xuXG4vKipcbiAqIGBtZ2wtcG9wdXBgIC0gYSBwb3B1cCBjb21wb25lbnRcbiAqIEBzZWUgW1BvcHVwXShodHRwczovL21hcGxpYnJlLm9yZy9tYXBsaWJyZS1nbC1qcy9kb2NzL0FQSS9jbGFzc2VzL1BvcHVwLylcbiAqXG4gKiBAY2F0ZWdvcnkgQ29tcG9uZW50c1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiAuLi5cbiAqIDxtZ2wtbWFwIC4uLj5cbiAqICAgPG1nbC1wb3B1cCBbbG5nTGF0XT1cIlstOTYsIDM3LjhdXCIgW2Nsb3NlT25DbGlja109XCJmYWxzZVwiPlxuICogICAgIDxoMT5IZWxsbyB3b3JsZCAhPC9oMT5cbiAqICAgPC9tZ2wtcG9wdXA+XG4gKiAgIC4uLlxuICogICA8bWdsLW1hcmtlciAjbXlNYXJrZXIgLi4uPiAuLi4gPC9tZ2wtbWFya2VyPlxuICogICA8bWdsLXBvcHVwIFttYXJrZXJdPVwibXlNYXJrZXJcIj4gSGVsbG8gZnJvbSBtYXJrZXIgISA8L21nbC1wb3B1cD5cbiAqIDwvbWdsLW1hcD5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtZ2wtcG9wdXAnLFxuICB0ZW1wbGF0ZTogJzxkaXYgI2NvbnRlbnQgZGF0YS1jeT1cIm1nbC1wb3B1cFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj4nLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5leHBvcnQgY2xhc3MgUG9wdXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgLyoqIEluaXQgaW5wdXQgKi9cbiAgQElucHV0KCkgY2xvc2VCdXR0b24/OiBQb3B1cE9wdGlvbnNbJ2Nsb3NlQnV0dG9uJ107XG4gIC8qKiBJbml0IGlucHV0ICovXG4gIEBJbnB1dCgpIGNsb3NlT25DbGljaz86IFBvcHVwT3B0aW9uc1snY2xvc2VPbkNsaWNrJ107XG4gIC8qKiBJbml0IGlucHV0ICovXG4gIEBJbnB1dCgpIGNsb3NlT25Nb3ZlPzogUG9wdXBPcHRpb25zWydjbG9zZU9uTW92ZSddO1xuICAvKiogSW5pdCBpbnB1dCAqL1xuICBASW5wdXQoKSBmb2N1c0FmdGVyT3Blbj86IFBvcHVwT3B0aW9uc1snZm9jdXNBZnRlck9wZW4nXTtcbiAgLyoqIEluaXQgaW5wdXQgKi9cbiAgQElucHV0KCkgYW5jaG9yPzogUG9wdXBPcHRpb25zWydhbmNob3InXTtcbiAgLyoqIEluaXQgaW5wdXQgKi9cbiAgQElucHV0KCkgY2xhc3NOYW1lPzogUG9wdXBPcHRpb25zWydjbGFzc05hbWUnXTtcbiAgLyoqIEluaXQgaW5wdXQgKi9cbiAgQElucHV0KCkgbWF4V2lkdGg/OiBQb3B1cE9wdGlvbnNbJ21heFdpZHRoJ107XG5cbiAgLyoqXG4gICAqIER5bmFtaWMgaW5wdXQgW25neF1cbiAgICogTXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggYGxuZ0xhdGBcbiAgICovXG4gIEBJbnB1dCgpIGZlYXR1cmU/OiBHZW9KU09OLkZlYXR1cmU8R2VvSlNPTi5Qb2ludD47XG4gIC8qKiBEeW5hbWljIGlucHV0ICovXG4gIEBJbnB1dCgpIGxuZ0xhdD86IExuZ0xhdExpa2U7XG4gIC8qKlxuICAgKiBEeW5hbWljIGlucHV0IFtuZ3hdXG4gICAqIFRoZSB0YXJnZXRlZCBtYXJrZXJcbiAgICovXG4gIEBJbnB1dCgpIG1hcmtlcj86IE1hcmtlckNvbXBvbmVudDtcbiAgLyoqIER5bmFtaWMgaW5wdXQgKi9cbiAgQElucHV0KCkgb2Zmc2V0PzogT2Zmc2V0O1xuXG4gIEBPdXRwdXQoKSBwb3B1cENsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICBAT3V0cHV0KCkgcG9wdXBPcGVuID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBAaGlkZGVuICovXG4gIEBWaWV3Q2hpbGQoJ2NvbnRlbnQnLCB7IHN0YXRpYzogdHJ1ZSB9KSBjb250ZW50OiBFbGVtZW50UmVmO1xuXG4gIHBvcHVwSW5zdGFuY2U/OiBtYXBsaWJyZWdsLlBvcHVwO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbWFwU2VydmljZTogTWFwU2VydmljZSkge1xuICAgIGFmdGVyTmV4dFJlbmRlcigoKSA9PiB7XG4gICAgICB0aGlzLnBvcHVwSW5zdGFuY2UgPSB0aGlzLmNyZWF0ZVBvcHVwKCk7XG4gICAgICB0aGlzLmFkZFBvcHVwKHRoaXMucG9wdXBJbnN0YW5jZSBhcyBQb3B1cCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoXG4gICAgICAodGhpcy5sbmdMYXQgJiYgdGhpcy5tYXJrZXIpIHx8XG4gICAgICAodGhpcy5mZWF0dXJlICYmIHRoaXMubG5nTGF0KSB8fFxuICAgICAgKHRoaXMuZmVhdHVyZSAmJiB0aGlzLm1hcmtlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VyLCBsbmdMYXQsIGZlYXR1cmUgaW5wdXQgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZScpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5mZWF0dXJlICYmICFjaGFuZ2VzLmZlYXR1cmUuaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICBjb25zdCBuZXdsbmdMYXQgPSBjaGFuZ2VzLmxuZ0xhdFxuICAgICAgICA/IHRoaXMubG5nTGF0IVxuICAgICAgICA6IDxbbnVtYmVyLCBudW1iZXJdPnRoaXMuZmVhdHVyZSEuZ2VvbWV0cnkhLmNvb3JkaW5hdGVzITtcbiAgICAgIHRoaXMubWFwU2VydmljZS5yZW1vdmVQb3B1cEZyb21NYXAodGhpcy5wb3B1cEluc3RhbmNlISwgdHJ1ZSk7XG4gICAgICBjb25zdCBwb3B1cEluc3RhbmNlVG1wID0gdGhpcy5jcmVhdGVQb3B1cCgpO1xuICAgICAgdGhpcy5tYXBTZXJ2aWNlLmFkZFBvcHVwVG9NYXAoXG4gICAgICAgIHBvcHVwSW5zdGFuY2VUbXAsXG4gICAgICAgIG5ld2xuZ0xhdCxcbiAgICAgICAgdGhpcy5wb3B1cEluc3RhbmNlIS5pc09wZW4oKVxuICAgICAgKTtcbiAgICAgIHRoaXMucG9wdXBJbnN0YW5jZSA9IHBvcHVwSW5zdGFuY2VUbXA7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMubG5nTGF0ICYmICFjaGFuZ2VzLmxuZ0xhdC5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIHRoaXMucG9wdXBJbnN0YW5jZSEuc2V0TG5nTGF0KHRoaXMubG5nTGF0ISk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMubWFya2VyICYmICFjaGFuZ2VzLm1hcmtlci5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzTWFya2VyOiBNYXJrZXJDb21wb25lbnQgPSBjaGFuZ2VzLm1hcmtlci5wcmV2aW91c1ZhbHVlO1xuICAgICAgaWYgKHByZXZpb3VzTWFya2VyLm1hcmtlckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMubWFwU2VydmljZS5yZW1vdmVQb3B1cEZyb21NYXJrZXIocHJldmlvdXNNYXJrZXIubWFya2VySW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWFya2VyICYmIHRoaXMubWFya2VyLm1hcmtlckluc3RhbmNlICYmIHRoaXMucG9wdXBJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLm1hcFNlcnZpY2UuYWRkUG9wdXBUb01hcmtlcihcbiAgICAgICAgICB0aGlzLm1hcmtlci5tYXJrZXJJbnN0YW5jZSxcbiAgICAgICAgICB0aGlzLnBvcHVwSW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFxuICAgICAgY2hhbmdlcy5vZmZzZXQgJiZcbiAgICAgICFjaGFuZ2VzLm9mZnNldC5pc0ZpcnN0Q2hhbmdlKCkgJiZcbiAgICAgIHRoaXMucG9wdXBJbnN0YW5jZVxuICAgICkge1xuICAgICAgdGhpcy5wb3B1cEluc3RhbmNlLnNldE9mZnNldCh0aGlzLm9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucG9wdXBJbnN0YW5jZSkge1xuICAgICAgaWYgKHRoaXMubG5nTGF0IHx8IHRoaXMuZmVhdHVyZSkge1xuICAgICAgICB0aGlzLm1hcFNlcnZpY2UucmVtb3ZlUG9wdXBGcm9tTWFwKHRoaXMucG9wdXBJbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWFya2VyICYmIHRoaXMubWFya2VyLm1hcmtlckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMubWFwU2VydmljZS5yZW1vdmVQb3B1cEZyb21NYXJrZXIodGhpcy5tYXJrZXIubWFya2VySW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBvcHVwSW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLm1hcFNlcnZpY2UuY3JlYXRlUG9wdXAoXG4gICAgICB7XG4gICAgICAgIHBvcHVwT3B0aW9uczoge1xuICAgICAgICAgIGNsb3NlQnV0dG9uOiB0aGlzLmNsb3NlQnV0dG9uLFxuICAgICAgICAgIGNsb3NlT25DbGljazogdGhpcy5jbG9zZU9uQ2xpY2ssXG4gICAgICAgICAgY2xvc2VPbk1vdmU6IHRoaXMuY2xvc2VPbk1vdmUsXG4gICAgICAgICAgZm9jdXNBZnRlck9wZW46IHRoaXMuZm9jdXNBZnRlck9wZW4sXG4gICAgICAgICAgYW5jaG9yOiB0aGlzLmFuY2hvcixcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jbGFzc05hbWUsXG4gICAgICAgICAgbWF4V2lkdGg6IHRoaXMubWF4V2lkdGgsXG4gICAgICAgIH0sXG4gICAgICAgIHBvcHVwRXZlbnRzOiB7XG4gICAgICAgICAgcG9wdXBPcGVuOiB0aGlzLnBvcHVwT3BlbixcbiAgICAgICAgICBwb3B1cENsb3NlOiB0aGlzLnBvcHVwQ2xvc2UsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGhpcy5jb250ZW50Lm5hdGl2ZUVsZW1lbnRcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRQb3B1cChwb3B1cDogUG9wdXApIHtcbiAgICB0aGlzLm1hcFNlcnZpY2UubWFwQ3JlYXRlZCQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmxuZ0xhdCB8fCB0aGlzLmZlYXR1cmUpIHtcbiAgICAgICAgdGhpcy5tYXBTZXJ2aWNlLmFkZFBvcHVwVG9NYXAoXG4gICAgICAgICAgcG9wdXAsXG4gICAgICAgICAgdGhpcy5sbmdMYXRcbiAgICAgICAgICAgID8gdGhpcy5sbmdMYXRcbiAgICAgICAgICAgIDogPFtudW1iZXIsIG51bWJlcl0+dGhpcy5mZWF0dXJlIS5nZW9tZXRyeSEuY29vcmRpbmF0ZXMhXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWFya2VyICYmIHRoaXMubWFya2VyLm1hcmtlckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMubWFwU2VydmljZS5hZGRQb3B1cFRvTWFya2VyKHRoaXMubWFya2VyLm1hcmtlckluc3RhbmNlLCBwb3B1cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ21nbC1wb3B1cCBuZWVkIGVpdGhlciBsbmdMYXQvbWFya2VyL2ZlYXR1cmUgdG8gYmUgc2V0J1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iXX0=