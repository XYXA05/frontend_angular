import { EventEmitter, NgZone } from '@angular/core';
import { CameraOptions, FlyToOptions, LngLatLike, MapOptions, MarkerOptions, PopupOptions, Map, Marker, Popup, AnimationOptions, LayerSpecification, StyleSpecification, LngLatBoundsLike, PointLike, IControl, SourceSpecification, FitBoundsOptions, Source, BackgroundLayerSpecification, FillLayerSpecification, FillExtrusionLayerSpecification, LineLayerSpecification, SymbolLayerSpecification, RasterLayerSpecification, CircleLayerSpecification, FilterSpecification, TerrainSpecification, QueryRenderedFeaturesOptions } from 'maplibre-gl';
import { Observable } from 'rxjs';
import { LayerEvents, MapEvent, MapImageData, MapImageOptions } from './map.types';
import * as i0 from "@angular/core";
export interface SetupMap {
    mapOptions: Omit<MapOptions, 'bearing' | 'pitch' | 'zoom'> & {
        bearing?: [number];
        pitch?: [number];
        zoom?: [number];
        terrain?: TerrainSpecification;
    };
    mapEvents: MapEvent;
}
export interface SetupLayer {
    layerOptions: LayerSpecification;
    layerEvents: LayerEvents;
}
export interface SetupPopup {
    popupOptions: PopupOptions;
    popupEvents: {
        popupOpen: EventEmitter<void>;
        popupClose: EventEmitter<void>;
    };
}
export interface SetupMarker {
    markersOptions: {
        pitchAlignment?: MarkerOptions['pitchAlignment'];
        rotationAlignment?: MarkerOptions['rotationAlignment'];
        rotation?: MarkerOptions['rotation'];
        offset?: MarkerOptions['offset'];
        anchor?: MarkerOptions['anchor'];
        color?: MarkerOptions['color'];
        draggable?: MarkerOptions['draggable'];
        element: HTMLElement;
        feature?: GeoJSON.Feature<GeoJSON.Point>;
        lngLat?: LngLatLike;
        clickTolerance?: MarkerOptions['clickTolerance'];
    };
    markersEvents: {
        markerDragStart: EventEmitter<Marker>;
        markerDrag: EventEmitter<Marker>;
        markerDragEnd: EventEmitter<Marker>;
    };
}
export type MovingOptions = FlyToOptions | (AnimationOptions & CameraOptions) | CameraOptions;
export declare class MapService {
    private zone;
    mapInstance: Map;
    mapCreated$: Observable<void>;
    mapLoaded$: Observable<void>;
    mapEvents: MapEvent;
    private mapCreated;
    private mapLoaded;
    private markersToRemove;
    private popupsToRemove;
    private imageIdsToRemove;
    private subscription;
    constructor(zone: NgZone);
    setup(options: SetupMap): void;
    destroyMap(): void;
    updateMinZoom(minZoom: number): void;
    updateMaxZoom(maxZoom: number): void;
    updateMinPitch(minPitch: number): void;
    updateMaxPitch(maxPitch: number): void;
    updateRenderWorldCopies(status: boolean): void;
    updateScrollZoom(status: boolean): void;
    updateDragRotate(status: boolean): void;
    updateTouchPitch(status: boolean): void;
    updateTouchZoomRotate(status: boolean): void;
    updateDoubleClickZoom(status: boolean): void;
    updateKeyboard(status: boolean): void;
    updateDragPan(status: boolean): void;
    updateBoxZoom(status: boolean): void;
    updateStyle(style: StyleSpecification): void;
    updateMaxBounds(maxBounds: LngLatBoundsLike): void;
    updateTerrain(options: TerrainSpecification): void;
    getTerrain(): TerrainSpecification | null;
    changeCanvasCursor(cursor: string): void;
    queryRenderedFeatures(pointOrBox?: PointLike | [PointLike, PointLike] | QueryRenderedFeaturesOptions, parameters?: QueryRenderedFeaturesOptions): GeoJSON.Feature<GeoJSON.GeometryObject>[];
    panTo(center: LngLatLike, options?: AnimationOptions): void;
    move(movingMethod: 'jumpTo' | 'easeTo' | 'flyTo', movingOptions?: MovingOptions, zoom?: number, center?: LngLatLike, bearing?: number, pitch?: number): void;
    addLayer(layer: SetupLayer, bindEvents: boolean, before?: string): void;
    removeLayer(layerId: string): void;
    addMarker(marker: SetupMarker): Marker;
    removeMarker(marker: Marker): void;
    createPopup(popup: SetupPopup, element: Node): Popup;
    addPopupToMap(popup: Popup, lngLat: LngLatLike, skipOpenEvent?: boolean): void;
    addPopupToMarker(marker: Marker, popup: Popup): void;
    removePopupFromMap(popup: Popup, skipCloseEvent?: boolean): void;
    removePopupFromMarker(marker: Marker): void;
    addControl(control: IControl, position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'): void;
    removeControl(control: IControl): void;
    loadAndAddImage(imageId: string, url: string, options?: MapImageOptions): Promise<void>;
    addImage(imageId: string, data: MapImageData, options?: MapImageOptions): void;
    removeImage(imageId: string): void;
    addSource(sourceId: string, source: SourceSpecification): void;
    getSource<T extends Source>(sourceId: string): T;
    removeSource(sourceId: string): void;
    setAllLayerPaintProperty(layerId: string, paint: BackgroundLayerSpecification['paint'] | FillLayerSpecification['paint'] | FillExtrusionLayerSpecification['paint'] | LineLayerSpecification['paint'] | SymbolLayerSpecification['paint'] | RasterLayerSpecification['paint'] | CircleLayerSpecification['paint']): void;
    setAllLayerLayoutProperty(layerId: string, layout: BackgroundLayerSpecification['layout'] | FillLayerSpecification['layout'] | FillExtrusionLayerSpecification['layout'] | LineLayerSpecification['layout'] | SymbolLayerSpecification['layout'] | RasterLayerSpecification['layout'] | CircleLayerSpecification['layout']): void;
    setLayerFilter(layerId: string, filter: FilterSpecification | null | undefined): void;
    setLayerBefore(layerId: string, beforeId: string): void;
    setLayerZoomRange(layerId: string, minZoom?: number, maxZoom?: number): void;
    fitBounds(bounds: LngLatBoundsLike, options?: FitBoundsOptions): void;
    fitScreenCoordinates(points: [PointLike, PointLike], bearing: number, options?: AnimationOptions & CameraOptions): void;
    applyChanges(): void;
    private createMap;
    private removeMarkers;
    private removePopups;
    private removeImages;
    private findLayersBySourceId;
    private hookEvents;
    static ɵfac: i0.ɵɵFactoryDeclaration<MapService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<MapService>;
}
